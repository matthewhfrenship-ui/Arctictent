<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Too Cool For New York</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:monospace;overflow:hidden}
  #three{position:fixed;inset:0}
  #startScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:#000a;z-index:10}
  button{padding:10px 20px;font-size:20px;background:#222;color:#fff;border:2px solid #555;border-radius:8px;cursor:pointer}
  #menu{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:360px;padding:20px;background:#222;border:3px solid #666;border-radius:12px;display:none;z-index:20;color:#fff;}
  #menu .row { display:flex;gap:8px;align-items:center;margin-top:8px; }
  #hud { position: fixed; left: 20px; bottom: 20px; z-index: 11; color: #fff; font-family: monospace; }
  .note { font-size:12px;color:#ccc;max-width:700px;text-align:center;margin-top:8px }
  #saveStatus { font-size:12px;color:#9ae6b4;margin-left:8px }
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<div id="three"></div>

<div id="startScreen">
  <h1 style="font-size:32px;color:#fff;">Too Cool For New York</h1>
  <button id="startBtn">Start Game</button>
</div>

<canvas id="minimapCanvas" width="150" height="150" style="display:none;position:fixed;right:20px;bottom:20px;z-index:10;border:3px solid #fff;border-radius:10px;background:#111;"></canvas>

<div id="menu">
  <h2>Game Menu</h2>
  <div class="row">
    <button id="saveBtn" onclick="savePlayerPosition()">Save</button>
    <button id="loadBtn" onclick="loadSavedPosition()">Load</button>
    <button id="deleteBtn" onclick="deleteSavedPosition()">Delete Save</button>
    <span id="saveStatus"></span>
  </div>
  <p style="margin-top:12px">Saved/Load will store the exact player position, rotation, and camera state to your browser (localStorage).</p>
  <div style="margin-top:12px">
    <button onclick="document.getElementById('menu').style.display='none'">Close</button>
  </div>
</div>

<div id="hud">
  <div id="hp">HP: 100</div>
  <div id="state">State: Idle</div>
</div>

<script>
'use strict';

/*
  Final consolidated demo implementing all requested features.
  - Start screen only shows title + Start button (controls text removed).
  - Minimap hidden until Start is pressed.
  - Arrow keys orbit camera (when not shift-locked). Shift + arrows rotate player.
  - Q = Dash, O/I = zoom in/out, +/- also zoom.
  - X = Attack, F = Block (hold), R = Respawn.
  - Buildings and pond are solid; sliding collision; spawn plaza kept clear.
  - Save/Load/Delete stores exact player position/rotation and camera state; loading nudges out of solids.
  - Various tuned parameters selected for balance.
*/

const PLAYER_RADIUS = 1.3;
const NPC_RADIUS = 0.9;

let scene, camera, renderer;
let terrainMesh = null;
let player;
let keys = {};
let shiftLock = false;
let gamePaused = true;
let npcs = [];
let buildings = [];
let buildingBoxes = [];
let animationStarted = false;
const clock = new THREE.Clock();

// Camera spherical params
let cameraYaw = 0;
let cameraPitch = 0.18;
let cameraDistance = 11;
let cameraPan = new THREE.Vector3(0,0,0);

const CAMERA_PAN_SPEED = 18.0;
const CAMERA_ANGLE_SPEED = 1.0;
const CAMERA_ZOOM_SPEED = 8;
const PITCH_MIN = -0.6;
const PITCH_MAX = 0.9;

// SPAWN: clear plaza in center
const SPAWN = { x: 0, z: 0 };
const spawnClearRadius = 80;

// Pond collision (non-walkable)
const pondCenter = new THREE.Vector3(8, 0, -10);
const pondRadius = 18;

// Player state
const playerState = {
  attacking: false,
  attackCooldown: 0,
  blocking: false,
  stunTimer: 0,
  health: 100,
  dashing: false,
  dashTimer: 0,
  dashDuration: 0.22,
  dashCooldown: 1.0,
  dashCooldownTimer: 0,
  dashSpeed: 52
};

// KEY HANDLERS (consistent normalization)
window.addEventListener('keydown', e=>{
  const k = (typeof e.key === 'string') ? e.key.toLowerCase() : String(e.key).toLowerCase();
  if(k === 'shift' && e.repeat) return;
  keys[k] = true;

  if(k === 'shift') shiftLock = !shiftLock;
  if(k === 'm') document.getElementById('menu').style.display='block';
  if(k === 'x') startAttack();
  if(k === 'f'){
    playerState.blocking = true;
    if(player) player.userData.anim = { type: 'block', t: 0 };
    updateHUD();
  }
  if(k === 'r') respawnPlayerAtSpawn();
  if(k === 'q') attemptDash();

  if(k === 'arrowleft' || k === 'arrowright' || k === 'arrowup' || k === 'arrowdown') {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e=>{
  const k = (typeof e.key === 'string') ? e.key.toLowerCase() : String(e.key).toLowerCase();
  keys[k] = false;
  if(k === 'f'){
    playerState.blocking = false;
    if(player) player.userData.anim = { type: 'idle', t: 0 };
    updateHUD();
  }
});

const startBtn = document.getElementById('startBtn');
startBtn.onclick = ()=>{
  startBtn.disabled = true;
  document.getElementById('startScreen').style.display='none';
  const mm = document.getElementById('minimapCanvas');
  if(mm) mm.style.display = 'block';
  gamePaused=false;
  if(!animationStarted){
    init3D();
    animate();
    animationStarted = true;
  }
};

// ---------- Scene init ----------
function init3D(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x87ceeb, 60, 600);

  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 5, cameraDistance);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.shadowMap.enabled = true;
  renderer.setSize(innerWidth, innerHeight);
  document.getElementById('three').appendChild(renderer.domElement);

  window.addEventListener('resize', onWindowResize);

  // Terrain
  const terrainGeo = new THREE.PlaneGeometry(800, 800, 120, 120);
  const posAttr = terrainGeo.attributes.position;
  for(let i=0;i<posAttr.count;i++){
    const x = posAttr.getX(i);
    const z = posAttr.getY ? posAttr.getY(i) : posAttr.getZ(i);
    const nx = x * 0.02, nz = z * 0.02;
    const y = Math.sin(nx*1.2 + nz*0.6) * 6 + Math.cos(nx*0.4 - nz*0.9)*3;
    posAttr.setZ(i, y);
  }
  terrainGeo.computeVertexNormals();
  const terrainMat = new THREE.MeshStandardMaterial({color:0x6fa86f, roughness:0.95});
  terrainMesh = new THREE.Mesh(terrainGeo, terrainMat);
  terrainMesh.rotation.x = -Math.PI/2;
  terrainMesh.receiveShadow = true;
  scene.add(terrainMesh);

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(60,120,40);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.left = -300;
  sun.shadow.camera.right = 300;
  sun.shadow.camera.top = 300;
  sun.shadow.camera.bottom = -300;
  scene.add(sun);

  // Pond (visual & collision)
  const pondGeo = new THREE.CircleGeometry(pondRadius, 32);
  const pondMat = new THREE.MeshStandardMaterial({color:0x356b9b, roughness:0.2, metalness:0.2});
  const pond = new THREE.Mesh(pondGeo, pondMat);
  pond.rotation.x = -Math.PI/2;
  pond.position.copy(pondCenter);
  scene.add(pond);

  // Player at SPAWN (spawn area guaranteed clear)
  player = createPenguin();
  const spawnY = getTerrainHeight(SPAWN.x, SPAWN.z) || 0;
  player.position.set(SPAWN.x, spawnY + 1.0, SPAWN.z);
  player.userData = { velocity: new THREE.Vector3(), anim: { type: 'idle', t: 0 } };
  scene.add(player);

  // Buildings - ensure none are generated inside spawnClearRadius or pond
  const bMat = new THREE.MeshStandardMaterial({color:0x666666, roughness:0.95});
  const desiredCount = 80;
  let attempts = 0;
  while(buildings.length < desiredCount && attempts < desiredCount * 6){
    attempts++;
    const w = 6 + Math.random()*30;
    const h = 6 + Math.random()*180;
    const d = 6 + Math.random()*30;
    const x = (Math.random()-0.8) * 300;
    const z = (Math.random()-0.3) * 220;
    const dxSpawn = x - SPAWN.x;
    const dzSpawn = z - SPAWN.z;
    const distToSpawn = Math.sqrt(dxSpawn*dxSpawn + dzSpawn*dzSpawn);
    if(distToSpawn < spawnClearRadius + Math.max(w,d)/2) continue;
    const dxP = x - pondCenter.x;
    const dzP = z - pondCenter.z;
    const distToPond = Math.sqrt(dxP*dxP + dzP*dzP);
    if(distToPond < pondRadius + Math.max(w,d)/2 + 2) continue;

    const geo = new THREE.BoxGeometry(w, h, d);
    const b = new THREE.Mesh(geo, bMat);
    const groundY = getTerrainHeight(x, z) || 0;
    b.position.set(x, groundY + h/2, z);
    b.castShadow = true;
    b.receiveShadow = true;
    scene.add(b);
    buildings.push(b);
    const box = new THREE.Box3().setFromObject(b);
    b.userData.box = box;
    buildingBoxes.push(box);
  }

  // NPCs (place 20 NPCs, outside spawnClearRadius)
  const npcCount = 20;
  for(let i=0;i<npcCount;i++){
    const npc = createHumanishNPC();
    let nx, nz;
    do {
      nx = (Math.random()-0.5)*160;
      nz = (Math.random()-0.5)*160;
    } while(Math.sqrt((nx-SPAWN.x)**2 + (nz-SPAWN.z)**2) < spawnClearRadius - 10);
    const terrainY = getTerrainHeight(nx, nz) || 0;
    npc.position.set(nx, terrainY + 1.0, nz);
    initializeNPCUserData(npc);
    scene.add(npc);
    npcs.push(npc);
  }

  updateHUD();
}

// get terrain height
function getTerrainHeight(x,z){
  const nx = x * 0.02, nz = z * 0.02;
  const y = Math.sin(nx*1.2 + nz*0.6) * 6 + Math.cos(nx*0.4 - nz*0.9)*3;
  return y;
}

// pond check
function isInsidePondAt(pos){
  const dx = pos.x - pondCenter.x;
  const dz = pos.z - pondCenter.z;
  return (dx*dx + dz*dz) <= (pondRadius * pondRadius);
}

// Check if position blocked by solids (buildings or pond)
function isPositionBlocked(pos, radius){
  if(isInsidePondAt(pos)) return true;
  for(let i=0;i<buildingBoxes.length;i++){
    const box = buildingBoxes[i];
    const expanded = box.clone().expandByScalar(radius);
    if(expanded.containsPoint(pos)) return true;
  }
  return false;
}

// Try to move entity with sliding
function tryMoveEntityWithCollisions(entity, moveVec, radius){
  const cur = entity.position.clone();
  const attempt = cur.clone().add(moveVec);
  const terrainY = getTerrainHeight(attempt.x, attempt.z) || 0;
  attempt.y = terrainY + (entity === player ? 1.0 : 1.1);

  if(!isPositionBlocked(attempt, radius)){
    entity.position.copy(attempt);
    return true;
  }

  const attemptX = cur.clone().add(new THREE.Vector3(moveVec.x,0,0));
  attemptX.y = getTerrainHeight(attemptX.x, attemptX.z) + (entity === player ? 1.0 : 1.1);
  if(!isPositionBlocked(attemptX, radius)){
    entity.position.copy(attemptX);
    return true;
  }

  const attemptZ = cur.clone().add(new THREE.Vector3(0,0,moveVec.z));
  attemptZ.y = getTerrainHeight(attemptZ.x, attemptZ.z) + (entity === player ? 1.0 : 1.1);
  if(!isPositionBlocked(attemptZ, radius)){
    entity.position.copy(attemptZ);
    return true;
  }

  return false;
}

// rebuild buildingBoxes after modifications
function rebuildBuildingBoxes(){
  buildingBoxes = [];
  buildings.forEach(b=>{
    b.userData.box = new THREE.Box3().setFromObject(b);
    buildingBoxes.push(b.userData.box);
  });
}

// remove nearest buildings
function removeNearestBuildings(count, center){
  if(!center || buildings.length === 0) return;
  const cx = center.x, cz = center.z;
  const list = buildings.map(b => {
    const dx = b.position.x - cx;
    const dz = b.position.z - cz;
    return { b, d: dx*dx + dz*dz };
  });
  list.sort((a,b)=>a.d - b.d);
  const toRemove = list.slice(0, count).map(x=>x.b);
  toRemove.forEach(b=>{
    scene.remove(b);
    const bi = buildings.indexOf(b);
    if(bi !== -1) buildings.splice(bi, 1);
  });
  rebuildBuildingBoxes();
}

// ---------- Save / Load / Delete ----------
const SAVE_KEY = 'tcfn_save';

function savePlayerPosition(){
  if(!player) return showSaveStatus('No player to save', true);
  const data = {
    player: {
      x: player.position.x,
      y: player.position.y,
      z: player.position.z,
      rotY: player.rotation.y
    },
    camera: {
      yaw: cameraYaw,
      pitch: cameraPitch,
      distance: cameraDistance,
      pan: { x: cameraPan.x, y: cameraPan.y, z: cameraPan.z }
    },
    timestamp: Date.now()
  };
  try {
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    showSaveStatus('Saved ✓', false);
  } catch (err) {
    console.error('Save failed', err);
    showSaveStatus('Save failed', true);
  }
}

function loadSavedPosition(){
  const raw = localStorage.getItem(SAVE_KEY);
  if(!raw) return showSaveStatus('No save found', true);
  try {
    const data = JSON.parse(raw);
    if(data.player){
      player.position.set(data.player.x, data.player.y, data.player.z);
      player.rotation.y = data.player.rotY != null ? data.player.rotY : player.rotation.y;
      resolveSavedPlayerPosition();
    }
    if(data.camera){
      cameraYaw = data.camera.yaw != null ? data.camera.yaw : cameraYaw;
      cameraPitch = data.camera.pitch != null ? data.camera.pitch : cameraPitch;
      cameraDistance = data.camera.distance != null ? data.camera.distance : cameraDistance;
      if(data.camera.pan){
        cameraPan.set(data.camera.pan.x, data.camera.pan.y, data.camera.pan.z);
      }
    }
    showSaveStatus('Loaded ✓', false);
    setTimeout(()=>{ document.getElementById('menu').style.display='none' }, 700);
  } catch(err){
    console.error('Load failed', err);
    showSaveStatus('Load failed', true);
  }
}

function deleteSavedPosition(){
  localStorage.removeItem(SAVE_KEY);
  showSaveStatus('Save deleted', false);
}

let saveStatusTimeout = null;
function showSaveStatus(msg, isError){
  const el = document.getElementById('saveStatus');
  if(!el) return;
  el.textContent = msg;
  el.style.color = isError ? '#ff6b6b' : '#9ae6b4';
  if(saveStatusTimeout) clearTimeout(saveStatusTimeout);
  saveStatusTimeout = setTimeout(()=>{ el.textContent = ''; }, 2500);
}

// nudge saved player position out of solids if required
function resolveSavedPlayerPosition(){
  const start = player.position.clone();
  const radius = PLAYER_RADIUS;
  if(!isPositionBlocked(start, radius) && !isInsidePondAt(start)) {
    const ty = getTerrainHeight(start.x, start.z) || 0;
    player.position.y = ty + 1.0;
    return;
  }
  const maxRadius = 12;
  const step = 1.0;
  for(let r = step; r <= maxRadius; r += step){
    const samples = 16;
    for(let s=0;s<samples;s++){
      const ang = (s/samples) * Math.PI * 2;
      const nx = start.x + Math.cos(ang) * r;
      const nz = start.z + Math.sin(ang) * r;
      const test = new THREE.Vector3(nx,0,nz);
      test.y = getTerrainHeight(nx,nz) + 1.0;
      if(!isPositionBlocked(test, radius) && !isInsidePondAt(test)){
        player.position.copy(test);
        return;
      }
    }
  }
  const spawnY = getTerrainHeight(SPAWN.x, SPAWN.z) || 0;
  player.position.set(SPAWN.x, spawnY + 1.0, SPAWN.z);
}

// ---------- Respawn ----------
function respawnPlayerAtSpawn(){
  if(!player) return;
  const spawnY = getTerrainHeight(SPAWN.x, SPAWN.z) || 0;
  player.position.set(SPAWN.x, spawnY + 1.0, SPAWN.z);
  player.rotation.y = 0;
  playerState.health = 100;
  playerState.stunTimer = 0;
  playerState.attacking = false;
  playerState.blocking = false;
  playerState.dashing = false;
  if(player) player.userData.anim = { type: 'idle', t: 0 };
  updateHUD();
}

// ---------- Dash ----------
function attemptDash(){
  if(playerState.dashing) return;
  if(playerState.dashCooldownTimer > 0) return;
  playerState.dashing = true;
  playerState.dashTimer = playerState.dashDuration;
  playerState.dashCooldownTimer = playerState.dashCooldown;
  if(player) player.userData.anim = { type: 'dash', t: 0 };
  updateHUD();
}

// ---------- Main loop ----------
function animate(){
  requestAnimationFrame(animate);
  if(!gamePaused) update3D();
  if(renderer && scene && camera) renderer.render(scene,camera);
  updateMinimap();
}

function update3D(){
  const dt = clock.getDelta();

  if(playerState.attackCooldown > 0) playerState.attackCooldown = Math.max(0, playerState.attackCooldown - dt);
  if(playerState.stunTimer > 0) playerState.stunTimer = Math.max(0, playerState.stunTimer - dt);
  if(playerState.dashCooldownTimer > 0) playerState.dashCooldownTimer = Math.max(0, playerState.dashCooldownTimer - dt);

  if(playerState.attacking){
    if(playerState.attackElapsed === undefined) playerState.attackElapsed = 0;
    playerState.attackElapsed += dt;
    if(playerState.attackElapsed > 0.25){
      playerState.attacking = false;
      playerState.attackElapsed = 0;
      player.userData.anim = { type: 'idle', t: 0 };
      updateHUD();
    }
  }

  // movement / dash
  let attemptedMove = new THREE.Vector3();
  const baseMoveSpeed = 5;
  const dir = new THREE.Vector3();
  player.getWorldDirection(dir);

  if(playerState.dashing){
    const dashVel = dir.clone().setY(0).normalize().multiplyScalar(playerState.dashSpeed * dt);
    tryMoveEntityWithCollisions(player, dashVel, PLAYER_RADIUS);
    playerState.dashTimer -= dt;
    if(playerState.dashTimer <= 0){
      playerState.dashing = false;
      player.userData.anim = { type: 'idle', t: 0 };
      updateHUD();
    }
  } else if(playerState.stunTimer <= 0){
    const moveSpeed = baseMoveSpeed * dt;
    if(keys['w']) attemptedMove.addScaledVector(dir, moveSpeed);
    if(keys['s']) attemptedMove.addScaledVector(dir, -moveSpeed);
    if(keys['a']) attemptedMove.addScaledVector(new THREE.Vector3(dir.z,0,-dir.x), moveSpeed);
    if(keys['d']) attemptedMove.addScaledVector(new THREE.Vector3(-dir.z,0,dir.x), moveSpeed);

    if(attemptedMove.lengthSq() > 0.000001){
      tryMoveEntityWithCollisions(player, attemptedMove, PLAYER_RADIUS);
    }
  }

  const terrainYp = getTerrainHeight(player.position.x, player.position.z) || 0;
  player.position.y = terrainYp + 1.0;
  if(isPositionBlocked(player.position, PLAYER_RADIUS) || isInsidePondAt(player.position)){
    resolveSavedPlayerPosition();
  }

  // camera orbit (arrows yaw/pitch), shift-lock rotates player
  const angleStep = CAMERA_ANGLE_SPEED * dt;
  const pitchStep = 0.9 * dt;
  if(shiftLock){
    const rotSpeed = 2.5 * dt;
    if(keys['arrowleft']) player.rotation.y += rotSpeed;
    if(keys['arrowright']) player.rotation.y -= rotSpeed;
    const pDir = new THREE.Vector3();
    player.getWorldDirection(pDir);
    const camPos = new THREE.Vector3(player.position.x - pDir.x*5, player.position.y+3, player.position.z - pDir.z*5);
    camera.position.lerp(camPos, 0.2);
  } else {
    if(keys['arrowleft']) cameraYaw += angleStep;
    if(keys['arrowright']) cameraYaw -= angleStep;
    if(keys['arrowup']) cameraPitch = Math.min(PITCH_MAX, cameraPitch + pitchStep);
    if(keys['arrowdown']) cameraPitch = Math.max(PITCH_MIN, cameraPitch - pitchStep);

    if(keys['o']) cameraDistance = Math.max(3, cameraDistance - CAMERA_ZOOM_SPEED * dt);
    if(keys['i']) cameraDistance = Math.min(160, cameraDistance + CAMERA_ZOOM_SPEED * dt);
    if(keys['='] || keys['+']) cameraDistance = Math.max(3, cameraDistance - CAMERA_ZOOM_SPEED * dt);
    if(keys['-'] || keys['_']) cameraDistance = Math.min(160, cameraDistance + CAMERA_ZOOM_SPEED * dt);

    const target = player.position.clone();
    const cosPitch = Math.cos(cameraPitch);
    const sinPitch = Math.sin(cameraPitch);
    const camX = target.x + Math.sin(cameraYaw) * cameraDistance * cosPitch;
    const camZ = target.z + Math.cos(cameraYaw) * cameraDistance * cosPitch;
    const camY = target.y + cameraDistance * sinPitch + 1.0;
    const targetPos = new THREE.Vector3(camX, camY, camZ);
    camera.position.lerp(targetPos, 0.14);

    const belowY = getTerrainHeight(camera.position.x, camera.position.z) || -9999;
    camera.position.y = Math.max(camera.position.y, belowY + 1.5);
  }

  const lookTarget = player.position.clone().add(new THREE.Vector3(0,1.0,0));
  camera.lookAt(lookTarget);

  animateCharacter(player, player.userData.anim, clock.getDelta(), true);

  // NPC behavior (movement & collisions)
  npcs.forEach((npc, idx) => {
    const ud = npc.userData;
    if(!ud) return;
    const pos = npc.position;
    ud.temp += (Math.random()-0.5) * 0.04;
    ud.temp = Math.max(0, Math.min(100, ud.temp));
    if(ud.stunTimer > 0) ud.stunTimer = Math.max(0, ud.stunTimer - clock.getDelta());

    const separation = new THREE.Vector3(), alignment = new THREE.Vector3(), cohesion = new THREE.Vector3();
    let neighborCount = 0;
    for(let j=0;j<npcs.length;j++){
      if(j === idx) continue;
      const other = npcs[j];
      const d = other.position.distanceTo(pos);
      if(d < 6){
        neighborCount++;
        const diff = pos.clone().sub(other.position).normalize().divideScalar(Math.max(d,0.0001));
        separation.add(diff);
        alignment.add(other.userData.velocity);
        cohesion.add(other.position);
      }
    }
    if(neighborCount > 0){
      alignment.divideScalar(neighborCount).normalize();
      cohesion.divideScalar(neighborCount).sub(pos).normalize();
    }

    ud.stateTimer -= clock.getDelta();
    if(ud.stunTimer > 0) ud.state = 'stunned';
    else {
      const distToPlayer = pos.distanceTo(player.position);
      if(distToPlayer < 3.5 && ud.stunTimer <= 0){
        if(ud.attackCooldown <= 0 && Math.random() < 0.015){
          ud.state = 'attacking';
          ud.attackCooldown = 1.0 + Math.random()*1.8;
          ud.stateTimer = 0.45;
        } else {
          ud.state = Math.random() < 0.5 ? 'approach' : 'idle';
        }
      } else if(ud.stateTimer <= 0){
        const r = Math.random();
        if(r < 0.55){
          ud.state = 'walk';
          ud.stateTimer = 1 + Math.random()*3;
          ud.dir = new THREE.Vector3((Math.random()-0.5),0,(Math.random()-0.5)).normalize();
        } else {
          ud.state = 'idle';
          ud.stateTimer = 1 + Math.random()*2;
        }
        if(Math.random() < 0.08 && neighborCount > 0){
          const others = npcs.filter((o,i)=>i!==idx && o.position.distanceTo(pos) < 6);
          if(others.length>0){
            ud.targetNPC = others[Math.floor(Math.random()*others.length)];
            ud.state = 'interact';
            ud.stateTimer = 2 + Math.random()*2.5;
          }
        }
      }
    }

    let desired = new THREE.Vector3();
    if(ud.state === 'stunned'){
      ud.velocity.multiplyScalar(0.9);
      ud.anim = { type: 'stunned', t: 0 };
    } else if(ud.state === 'idle'){
      ud.velocity.multiplyScalar(0.92);
      ud.anim = { type: 'idle', t: 0 };
    } else if(ud.state === 'walk' || ud.state === 'approach'){
      if(ud.state === 'approach'){
        desired.copy(player.position).sub(pos).setY(0).normalize().multiplyScalar(ud.speed * 0.9);
      } else {
        desired.copy(ud.dir).multiplyScalar(ud.speed * 0.6);
      }
      desired.add(separation.multiplyScalar(1.0));
      desired.add(alignment.multiplyScalar(0.4));
      desired.add(cohesion.multiplyScalar(0.25));
      ud.velocity.lerp(desired, 0.05);
      ud.anim = { type: 'walk', t: ud.velocity.length() };
    } else if(ud.state === 'attacking'){
      desired.copy(player.position).sub(pos).setY(0).normalize().multiplyScalar(ud.speed * 1.6);
      ud.velocity.lerp(desired, 0.22);
      ud.anim = { type: 'attack', t: 0 };
      if(ud.stateTimer <= 0.005){
        if(pos.distanceTo(player.position) < 2.2){
          if(playerState.blocking){
            playerState.stunTimer = Math.min(playerState.stunTimer + 0.08, 0.5);
            playerState.health = Math.max(0, playerState.health - 2);
          } else {
            playerState.stunTimer = Math.min(playerState.stunTimer + 0.5, 1.6);
            playerState.health = Math.max(0, playerState.health - (6 + Math.floor(Math.random()*8)));
            const kb = player.position.clone().sub(pos).setY(0).normalize().multiplyScalar(1.2);
            player.position.add(kb);
          }
          updateHUD();
        }
      }
    } else if(ud.state === 'interact'){
      if(ud.targetNPC){
        const toTarget = ud.targetNPC.position.clone().sub(pos).setY(0);
        if(toTarget.length() > 1.2){
          desired.copy(toTarget.normalize()).multiplyScalar(ud.speed * 0.28);
          ud.velocity.lerp(desired, 0.04);
        } else {
          ud.velocity.multiplyScalar(0.5);
        }
        ud.anim = { type: 'talk', t: 0 };
      } else {
        ud.state = 'idle';
      }
    }

    const moveVec = ud.velocity.clone().multiplyScalar(clock.getDelta() * 60);
    tryMoveEntityWithCollisions(npc, moveVec, NPC_RADIUS);

    const terrainY = getTerrainHeight(npc.position.x, npc.position.z) || 0;
    npc.position.y = terrainY + 0.1 + 1.0;

    const lookTarget = (ud.state === 'attacking') ? player.position : npc.position.clone().add(ud.velocity);
    if(ud.velocity.lengthSq() > 0.0001 || ud.state === 'attacking'){
      const vx = (lookTarget.x - npc.position.x);
      const vz = (lookTarget.z - npc.position.z);
      const desiredY = Math.atan2(vx, vz);
      const diff = normalizeAngle(desiredY - npc.rotation.y);
      npc.rotation.y += diff * 0.12;
    }

    if(ud.attackCooldown > 0) ud.attackCooldown = Math.max(0, ud.attackCooldown - clock.getDelta());
    animateCharacter(npc, ud.anim, clock.getDelta(), false);

    const spr = ud.tempSprite;
    if(spr && spr.userData){
      spr.userData.drawTemp(ud.temp);
      spr.userData.tex.needsUpdate = true;
    }

    if(ud.health <= 0){
      ud.state = 'down';
      if(!ud.deadTimer) ud.deadTimer = 3.0;
      ud.deadTimer -= clock.getDelta();
      npc.scale.y = Math.max(0.01, npc.scale.y - clock.getDelta() * 0.2);
      if(ud.deadTimer <= 0){
        npc.position.set((Math.random()-0.5)*80, 1.1, (Math.random()-0.5)*80);
        ud.health = 20 + Math.random()*30;
        npc.scale.setScalar(0.85);
        ud.deadTimer = null;
        ud.state = 'idle';
      }
    }
  });

  const bound = 380;
  player.position.x = Math.max(-bound, Math.min(bound, player.position.x));
  player.position.z = Math.max(-bound, Math.min(bound, player.position.z));
}

// ---------- Animations, models & helpers (procedural animations, penguin & humanish NPCs, temp sprites) ----------
function animateCharacter(group, anim, dt, isPlayer){
  if(!group) return;
  const wingL = group.getObjectByName('wingL');
  const wingR = group.getObjectByName('wingR');
  const head = group.getObjectByName('head');
  const torso = group.getObjectByName('torso') || group.getObjectByName('body');
  const a = anim || { type: 'idle', t: 0 };
  a.t = (a.t || 0) + dt * 3;
  if(a.type === 'attack'){
    const p = Math.min(1, a.t*2);
    const swing = Math.sin(p*Math.PI) * 1.6;
    if(wingL) wingL.rotation.z = -0.6 * swing;
    if(wingR) wingR.rotation.z = 0.6 * swing;
    if(torso) torso.rotation.x = -0.15 * swing;
    if(head) head.rotation.x = 0.12 * swing;
  } else if(a.type === 'block'){
    const p = Math.min(1, a.t*1.6);
    if(wingL) wingL.rotation.z = 0.6 * p;
    if(wingR) wingR.rotation.z = -0.6 * p;
    if(torso) torso.rotation.x = 0.08 * p;
    if(head) head.rotation.x = -0.06 * p;
    if(playerState.blocking) a.t += dt;
  } else if(a.type === 'dash'){
    const p = Math.min(1, a.t*6);
    if(wingL) wingL.rotation.z = -0.35 * (1 + Math.sin(a.t*20)*0.15);
    if(wingR) wingR.rotation.z = 0.35 * (1 + Math.sin(a.t*20)*0.15);
    if(torso) torso.rotation.x = -0.25 * p;
    if(head) head.rotation.x = 0.12 * p;
    a.t += dt * 4;
  } else if(a.type === 'walk'){
    const speed = a.t || 0.6;
    const s = Math.sin(clock.getElapsedTime()*6) * 0.35 * Math.min(1, speed*1.8);
    if(wingL) wingL.rotation.z = 0.18 + s;
    if(wingR) wingR.rotation.z = -0.18 - s;
    if(torso) torso.rotation.x = Math.sin(clock.getElapsedTime()*2)*0.02;
    if(head) head.rotation.x = Math.sin(clock.getElapsedTime()*1.5)*0.02;
  } else if(a.type === 'talk'){
    const s = Math.sin(clock.getElapsedTime()*4) * 0.12;
    if(wingL) wingL.rotation.z = 0.18 + s;
    if(wingR) wingR.rotation.z = -0.18 - s;
    if(head) head.rotation.x = Math.sin(clock.getElapsedTime()*2)*0.03;
  } else if(a.type === 'stunned'){
    if(wingL) wingL.rotation.z = 0.5;
    if(wingR) wingR.rotation.z = -0.5;
    if(torso) torso.rotation.x = 0.25;
    if(head) head.rotation.x = 0.25;
  } else {
    const s = Math.sin(clock.getElapsedTime()*1.4) * 0.06;
    if(wingL) wingL.rotation.z = 0.18 + s*0.3;
    if(wingR) wingR.rotation.z = -0.18 - s*0.3;
    if(torso) torso.rotation.x = s*0.08;
    if(head) head.rotation.x = s*0.03;
  }
  group.userData.anim = a;
}

function startAttack(){
  if(playerState.attackCooldown > 0 || playerState.attacking || playerState.stunTimer > 0) return;
  playerState.attacking = true;
  playerState.attackCooldown = 0.7 + Math.random()*0.4;
  playerState.attackElapsed = 0;
  if(player) player.userData.anim = { type: 'attack', t: 0 };
  updateHUD();
  const range = 3.0;
  const forward = new THREE.Vector3();
  player.getWorldDirection(forward);
  npcs.forEach(npc=>{
    if(npc.userData.stunTimer > 0 || npc.userData.health <= 0) return;
    const offset = npc.position.clone().sub(player.position);
    const dist = offset.length();
    if(dist <= range){
      const dirToNpc = offset.clone().setY(0).normalize();
      const dot = forward.clone().setY(0).normalize().dot(dirToNpc);
      if(dot > 0.4){
        let dmg = 8 + Math.floor(Math.random()*6);
        const kb = offset.clone().setY(0).normalize().multiplyScalar(1.8 + Math.random()*0.6);
        npc.position.add(kb);
        npc.userData.stunTimer = 0.6 + Math.random()*0.6;
        npc.userData.health -= dmg;
        npc.userData.state = 'stunned';
        npc.userData.temp = Math.min(100, npc.userData.temp + 2 + Math.random()*3);
      }
    }
  });
}

// createPenguin, createHumanishNPC, initializeNPCUserData, createTempSprite, roundRect implementations:

function createPenguin(){
  const peng = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({color:0x223344, roughness:0.4, metalness:0.1});
  const whiteMat = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.7});
  const beakMat = new THREE.MeshStandardMaterial({color:0xffaa00});
  const body = new THREE.Mesh(new THREE.SphereGeometry(1,24,24), bodyMat);
  body.scale.set(1,1.3,1); body.castShadow = true; body.name = 'body'; peng.add(body);
  const belly = new THREE.Mesh(new THREE.SphereGeometry(0.8,24,24), whiteMat);
  belly.position.set(0,-0.1,0.55); belly.castShadow = true; belly.name = 'belly'; peng.add(belly);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.6,24,24), bodyMat);
  head.position.y = 1.2; head.castShadow = true; head.name = 'head'; peng.add(head);
  const beak = new THREE.Mesh(new THREE.ConeGeometry(0.25,0.6,12), beakMat);
  beak.position.set(0,1.1,0.55); beak.rotation.x = Math.PI/2; beak.castShadow = true; beak.name = 'beak'; peng.add(beak);
  const wingGeo = new THREE.BoxGeometry(0.15, 0.6, 0.9);
  const wingL = new THREE.Mesh(wingGeo, bodyMat); wingL.position.set(-0.9, 0.5, 0); wingL.rotation.z = 0.18; wingL.name = 'wingL'; peng.add(wingL);
  const wingR = wingL.clone(); wingR.position.x = 0.9; wingR.rotation.z = -0.18; wingR.name = 'wingR'; peng.add(wingR);
  return peng;
}

function createHumanishNPC(){
  const g = new THREE.Group();
  const skinMat = new THREE.MeshStandardMaterial({color:0xffe0c0, roughness:0.8});
  const clothMat = new THREE.MeshStandardMaterial({color:0x223344, roughness:0.6});
  const hairMat = new THREE.MeshStandardMaterial({color:0x1a1a1a, roughness:0.8});
  const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,1.2,12), clothMat); torso.position.y = 1.0; torso.castShadow = true; torso.name = 'torso'; g.add(torso);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.38,12,12), skinMat); head.position.y = 1.9; head.name = 'head'; g.add(head);
  const hair = new THREE.Mesh(new THREE.SphereGeometry(0.4,12,12), hairMat); hair.position.y = 2.0; g.add(hair);
  const armGeo = new THREE.CylinderGeometry(0.08,0.08,0.9,8);
  const armL = new THREE.Mesh(armGeo, skinMat); armL.position.set(-0.7,1.4,0); armL.rotation.z = 0.2; armL.name = 'armL'; g.add(armL);
  const armR = armL.clone(); armR.position.x = 0.7; armR.rotation.z = -0.2; armR.name = 'armR'; g.add(armR);
  const legGeo = new THREE.CylinderGeometry(0.12,0.12,1.0,8);
  const legL = new THREE.Mesh(legGeo, clothMat); legL.position.set(-0.22,0.1,0); legL.name = 'legL'; g.add(legL);
  const legR = legL.clone(); legR.position.x = 0.22; legR.name = 'legR'; g.add(legR);
  const shirtAccent = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.08,0.02), new THREE.MeshStandardMaterial({color:0xffcc00}));
  shirtAccent.position.set(0,1.15,0.62); g.add(shirtAccent);
  return g;
}

function initializeNPCUserData(npc){
  npc.userData = {
    state: 'idle',
    stateTimer: Math.random()*3 + 1,
    dir: new THREE.Vector3((Math.random()-0.5),0,(Math.random()-0.5)).normalize(),
    velocity: new THREE.Vector3(),
    speed: 0.6 + Math.random()*0.9,
    health: 25 + Math.random()*30,
    attackCooldown: Math.random()*2,
    stunTimer: 0,
    temp: 40 + Math.random()*20,
    tempSprite: createTempSprite(Math.random()*100),
    targetNPC: null
  };
  const spr = npc.userData.tempSprite;
  spr.position.set(0, 2.6, 0);
  spr.scale.set(1.6, 0.36, 1);
  npc.add(spr);
}

function createTempSprite(initial){
  const canvas = document.createElement('canvas');
  canvas.width = 128; canvas.height = 24;
  const ctx = canvas.getContext('2d');
  function drawTemp(temp){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(ctx, 0, 0, canvas.width, canvas.height, 4, true, false);
    ctx.fillStyle = '#333';
    roundRect(ctx, 6, 6, canvas.width-12, 12, 3, true, false);
    const pct = Math.max(0, Math.min(1, temp/100));
    const grad = ctx.createLinearGradient(6,6,6 + (canvas.width-12)*pct, 18);
    grad.addColorStop(0, '#00aaff');
    grad.addColorStop(0.5, '#ffff66');
    grad.addColorStop(1, '#ff4444');
    ctx.fillStyle = grad;
    roundRect(ctx, 6, 6, (canvas.width-12)*pct, 12, 3, true, false);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(Math.round(temp) + '°', canvas.width/2, 18);
  }
  drawTemp(initial);
  const tex = new THREE.CanvasTexture(canvas);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  const mat = new THREE.SpriteMaterial({ map: tex, depthTest: true, depthWrite: false });
  const spr = new THREE.Sprite(mat);
  spr.userData = { canvas, ctx, tex, drawTemp };
  return spr;
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof stroke == 'undefined') stroke = true;
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// Minimap / HUD / Resize helpers
function updateMinimap(){
  const map = document.getElementById('minimapCanvas');
  if(!map || !player) return;
  const ctx = map.getContext('2d');
  const centerX = map.width/2;
  const centerY = map.height/2;
  const scale = 0.35;
  const markerSize = 5;
  ctx.clearRect(0,0,map.width,map.height);
  ctx.fillStyle='#111'; ctx.fillRect(0,0,map.width,map.height);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(0,0,map.width,map.height);
  ctx.fillStyle = '#666';
  buildings.forEach(b=>{
    const x = Math.round(centerX + b.position.x*scale - 2);
    const y = Math.round(centerY + b.position.z*scale - 2);
    if(x >= -10 && x <= map.width+10 && y >= -10 && y <= map.height+10){
      ctx.fillRect(x, y, 3, 3);
    }
  });
  ctx.fillStyle='#0f0';
  const px = Math.round(centerX + player.position.x*scale - markerSize/2);
  const py = Math.round(centerY + player.position.z*scale - markerSize/2);
  ctx.fillRect(px, py, markerSize, markerSize);
  npcs.forEach(npc=>{
    const nx = Math.round(centerX + npc.position.x*scale - 2);
    const ny = Math.round(centerY + npc.position.z*scale - 2);
    const t = npc.userData.temp;
    let c = '#aaa';
    if(t > 70) c = '#ff6b6b';
    else if(t > 50) c = '#ffd166';
    else c = '#9ae6b4';
    if(nx >= -10 && nx <= map.width+10 && ny >= -10 && ny <= map.height+10){
      ctx.fillStyle = c;
      ctx.fillRect(nx, ny, 3, 3);
    }
  });
  ctx.fillStyle = '#fff'; ctx.font = '10px monospace'; ctx.fillText('N', centerX - 4, 10);
}

function onWindowResize(){
  if(!camera || !renderer) return;
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

function updateHUD(){
  const hpEl = document.getElementById('hp');
  const stateEl = document.getElementById('state');
  hpEl.textContent = `HP: ${Math.max(0, Math.round(playerState.health))}`;
  let st = 'Idle';
  if(playerState.dashing) st = 'Dashing';
  else if(playerState.attacking) st = 'Attacking';
  else if(playerState.blocking) st = 'Blocking';
  else if(playerState.stunTimer > 0) st = 'Stunned';
  stateEl.textContent = `State: ${st}`;
}

function normalizeAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}
</script>
</body>
</html>
